#' Calculate Outcome Stability for Each Element of Practice x Outcome
#'
#' This function splits the `data.table` output by `PrepareStabData` into a list using the `Outcome` and `Practice` fields,
#' then applies `ERAg::StabCalc` to each element of the list. The results are concatenated and returned in a list.
#'
#' @param Data A `data.table` generated by the `ERAg::PrepareStabData` function.
#' @param Do.Weight Logical. If `TRUE`, coefficient estimates are weighted according to the weightings in the `Data` object (default = TRUE).
#' @param Weight.by.Study Logical. This parameter is deprecated (default = TRUE).
#' @param Rm.Out Logical. If `TRUE`, extreme outliers are removed within each Practice x Outcome combination (default = TRUE).
#' @param Transform Logical. If `TRUE`, back-transformed coefficient estimates and confidence intervals are appended to outputs (default = TRUE).
#' @param DoRandom Logical. If `TRUE`, random effects models are included (default = TRUE).
#' @param Control List of control values for the `rma.mv` estimation algorithm. Defaults to `list(optimizer="optim", optmethod="Nelder-Mead", maxit=10000)`.
#' @param Responses Character vector of response variables (default = `c("lnRR","lnVR","lnCVR")`).
#' @param Use.acv Logical. If `TRUE`, uses the scale-adjusted coefficient of variation (acv) instead of the coefficient of variation (cv) (default = FALSE).
#' @param Inc.Prod Logical. If `TRUE`, analysis is conducted at the Crop x Outcome x Practice level (default = FALSE).
#' @param Cores Integer. Number of cores to use for parallel processing. If `Cores = 1`, runs sequentially (default = 1).
#' @return A list containing:
#' \enumerate{
#' \item `[[StabStats]]`: Results from `ERAg::StabCalc` for each Practice x Outcome (and EU if `Inc.Prod = TRUE`).
#' \item `[[StabStats.Test]]`: Equivalent of the `[[Tests]]` output from `ERAg::StabCalc`.
#' \item `[[StabStats.Tab]]`: Equivalent of the `[[Coefs]]` output from `ERAg::StabCalc`.
#' \item `[[StabStats.Test2]]`: Equivalent of the `[[Tests2]]` output from `ERAg::StabCalc`.
#' \item `[[StabList]]`: A list of the input `Data`, split by Practice and Outcome (and EU if `Inc.Prod = TRUE`).
#' }
#' @export
#' @import data.table
#' @importFrom future.apply future_lapply
#' @importFrom future plan multisession sequential
#' @importFrom data.table dcast rbindlist
StabCalc2 <- function(Data,
                      Do.Weight = TRUE,
                      Weight.by.Study = TRUE,  # Deprecated
                      Rm.Out = TRUE,
                      Transform = TRUE,
                      DoRandom = TRUE,
                      Control = list(optimizer = "optim", optmethod = "Nelder-Mead", maxit = 10000),
                      Responses = c("lnRR", "lnVR", "lnCVR"),
                      Use.acv = FALSE,
                      Inc.Prod = FALSE,
                      Cores = 1) {

  Data <- data.table(Data)

  # Ensure data has at least 3 years
  Data <- Data[nryears >= 3]

  # Split data by Outcome and Practice (and EU if Inc.Prod is TRUE)
  if (Inc.Prod) {
    Data <- split(Data, list(Data$Outcome, Data$Practice, Data$EU))
  } else {
    Data <- split(Data, list(Data$Outcome, Data$Practice))
  }

  # Remove datasets with less than 3 rows
  Data <- Data[unlist(lapply(Data, nrow)) >= 3]

  # Set parallel or sequential plan based on the number of cores
  if (Cores > 1) {
    future::plan(future::multisession, workers = Cores)
  } else {
    future::plan(future::sequential)
  }

  # Apply StabCalc function to each subset of the data
  StabStats <- future.apply::future_lapply(1:length(Data), function(i) {
    DATA <- Data[[i]]
    ERAg::StabCalc(
      Data = DATA,
      Do.Weight = Do.Weight,
      Weight.by.Study = Weight.by.Study,
      Rm.Out = Rm.Out,
      Transform = Transform,
      DoRandom = DoRandom,
      Control = Control,
      Responses = Responses,
      Use.acv = Use.acv
    )
  })

  # Reset plan back to sequential after parallel computation
  future::plan(future::sequential)

  # Combine results into tables
  StabStats.Tab <- rbindlist(lapply(StabStats, "[[", "Coefs"))
  StabStats.Tab[, `:=`(
    N.Seq = round(mean(N.Seq), 0),
    N.Obs = round(mean(N.Obs), 0),
    N.Studies = round(mean(N.Studies), 0)
  )]

  if (Inc.Prod) {
    StabStats.Tab <- dcast(StabStats.Tab, Model + Robust + N.Studies + N.Seq + N.Obs + Practice + Outcome + EU ~ Response,
                           value.var = c("Mean", "SE", "Z.val", "CI.low", "CI.high", "P.Vals", "Mean.Jen", "CI.low.Jen", "CI.high.Jen"))
  } else {
    StabStats.Tab <- dcast(StabStats.Tab, Model + Robust + N.Studies + N.Seq + N.Obs + Practice + Outcome ~ Response,
                           value.var = c("Mean", "SE", "Z.val", "CI.low", "CI.high", "P.Vals", "Mean.Jen", "CI.low.Jen", "CI.high.Jen"))
  }

  if (Inc.Prod) {
    StabStats.Test <- dcast(rbindlist(lapply(StabStats, "[[", "Tests")),
                            Practice + Outcome + EU + Robust + N.Obs + N.Studies ~ Variable + Coefficient,
                            value.var = c("Estimate", "Std. Error", "t value", "Pr(>|t|)", "PSymbol", "Mean.Jen", "CI.low.Jen", "CI.high.Jen"))
  } else {
    StabStats.Test <- dcast(rbindlist(lapply(StabStats, "[[", "Tests")),
                            Practice + Outcome + Robust + N.Obs + N.Studies ~ Variable + Coefficient,
                            value.var = c("Estimate", "Std. Error", "t value", "Pr(>|t|)", "PSymbol", "Mean.Jen", "CI.low.Jen", "CI.high.Jen"))
  }
  StabStats.Test[, Prac.x.Out := paste0(Outcome, ".", Practice)]

  StabStats.Test2 <- rbindlist(lapply(StabStats, "[[", "Tests2"))

  return(list(StabStats = StabStats, StabStats.Test = StabStats.Test, StabStats.Tab = StabStats.Tab, StabStats.Test2 = StabStats.Test2, StabList = Data))
}
